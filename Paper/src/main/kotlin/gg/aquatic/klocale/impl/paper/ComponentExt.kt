package gg.aquatic.klocale.impl.paper

import net.kyori.adventure.text.Component
import net.kyori.adventure.text.TextComponent
import net.kyori.adventure.text.TextReplacementConfig
import net.kyori.adventure.text.event.HoverEvent
import net.kyori.adventure.text.format.Style
import net.kyori.adventure.text.minimessage.MiniMessage
import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer

val PLACEHOLDER_REGEX = Regex("%([^%]+)%")

/**
 * Finds all unique placeholders within this Component and its children.
 * A placeholder is defined by a specific pattern, typically surrounded by
 * specific symbols (e.g., `%placeholder%`). The search is recursive,
 * traversing all nested child components.
 *
 * @return a set of strings representing unique placeholders found within the component hierarchy.
 */
fun Component.findPlaceholders(): Set<String> {
    val result = mutableSetOf<String>()

    fun recurse(comp: Component) {
        if (comp is TextComponent) {
            val text = comp.content()
            PLACEHOLDER_REGEX.findAll(text).forEach { match ->
                result.add(match.groupValues[1]) // only the inside of %...%
            }
        }
        for (child in comp.children()) {
            recurse(child)
        }
    }

    recurse(this)
    return result
}

/**
 * Replaces placeholders within a Component object and its children using the provided updater function.
 * The method applies transformations recursively to text content, insertion text, and hover events.
 *
 * @param updater a function that takes a string and returns an updated string. This function is applied to
 *                text content and insertion text within the component's structure.
 * @return a new Component object where all placeholders have been replaced as per the updater function.
 */
fun Component.replacePlaceholders(updater: (String) -> String): Component {
    fun recurse(comp: Component): Component {
        val style = comp.style()
        var newStyle = style

        // Handle hover event if present
        style.hoverEvent()?.let { hover ->
            if (hover.action() == HoverEvent.Action.SHOW_TEXT) {
                val hoverComp = hover.value() as? Component
                if (hoverComp != null) {
                    val replacedHover = recurse(hoverComp)
                    newStyle = newStyle.hoverEvent(HoverEvent.showText(replacedHover))
                }
            }
        }

        // Handle insertion text (plain string)
        style.insertion()?.let { insertion ->
            val newInsertion = updater(insertion)
            newStyle = newStyle.insertion(newInsertion)
        }

        var newComponent = if (comp is TextComponent) {
            val newText = updater(comp.content())
            val rebuilt = Component.text(newText).style(newStyle)
            rebuilt
        } else {
            val rebuilt: Component = comp.style(newStyle)
            rebuilt
        }
        for (child in comp.children()) {
            newComponent = newComponent.append(recurse(child))
        }
        return newComponent
    }
    return recurse(this)
}

/**
 * Replaces parts of this Component with other Components based on a mapping.
 *
 * The method traverses the current Component structure recursively, searching for
 * string keys specified in the provided map. When a key is found, it is replaced
 * with the corresponding Component generated by the map value function. The Style
 * of the replaced parts is preserved.
 *
 * @param map A map where keys are strings to be replaced and values are functions
 *            that return the replacement Components.
 * @return A new Component with the specified replacements applied.
 */
fun Component.replaceWith(map: Map<String, () -> Component>): Component {
    fun recurseSplit(mapLeft: Map<String, () -> Component>, str: String, style: Style): Component {
        var component = Component.text()
        val left = mapLeft.toMutableMap()

        var found = false
        mapLeft.forEach { (key, value) ->
            if (str.contains(key)) {
                left -= key

                val split = str.split(key)

                for ((index, string) in split.withIndex()) {
                    component = component.append(recurseSplit(left.toMutableMap(), string, style))
                    if (index < split.size - 1) {
                        component = component.append(value)
                    }
                }
                found = true
            }
        }
        if (!found) {
            component = component.append(Component.text(str, style))
        }
        return component.build()
    }

    fun recurse(comp: Component): Component {
        val style = comp.style()
        var newStyle = style

        // Handle hover event if present
        style.hoverEvent()?.let { hover ->
            if (hover.action() == HoverEvent.Action.SHOW_TEXT) {
                val hoverComp = hover.value() as? Component
                if (hoverComp != null) {
                    val replacedHover = recurse(hoverComp)
                    newStyle = newStyle.hoverEvent(HoverEvent.showText(replacedHover))
                }
            }
        }

        var newComponent = if (comp is TextComponent) {
            recurseSplit(map, comp.content(), newStyle)
        } else {
            val rebuilt: Component = comp.style(newStyle)
            rebuilt
        }
        for (child in comp.children()) {
            newComponent = newComponent.append(recurse(child))
        }
        return newComponent
    }
    return recurse(this)
}

/**
 * Only use when we 100% know that we got predefined placeholders
 */
fun Component.replacePlaceholders(cached: Map<String, String>): Component {
    fun recurse(comp: Component): Component {
        val style = comp.style()
        var newStyle = style

        // Handle hover event if present
        style.hoverEvent()?.let { hover ->
            if (hover.action() == HoverEvent.Action.SHOW_TEXT) {
                val hoverComp = hover.value() as? Component
                if (hoverComp != null) {
                    val replacedHover = recurse(hoverComp)
                    newStyle = newStyle.hoverEvent(HoverEvent.showText(replacedHover))
                }
            }
        }

        // Handle insertion text (plain string)
        style.insertion()?.let { insertion ->
            var newInsertion = insertion
            PLACEHOLDER_REGEX.findAll(insertion).forEach { match ->
                val key = match.groupValues[1]
                newInsertion = insertion.replace("%$key%", cached[key] ?: key)
            }
            newStyle = newStyle.insertion(newInsertion)
        }

        var newComponent = if (comp is TextComponent) {
            var newText = comp.content()
            PLACEHOLDER_REGEX.findAll(newText).forEach { match ->
                val key = match.groupValues[1]
                newText = newText.replace("%$key%", cached[key] ?: key)
            }
            val rebuilt = Component.text(newText).style(newStyle)
            rebuilt
        } else {
            val rebuilt: Component = comp.style(newStyle)
            rebuilt
        }
        for (child in comp.children()) {
            newComponent = newComponent.append(recurse(child))
        }
        return newComponent
    }
    return recurse(this)
}

/**
 * Determines if the current component or any of its child components contain placeholders.
 * A placeholder is identified using a predefined regex pattern within the content of a
 * TextComponent or its descendants.
 *
 * @return true if a placeholder is found within the component or its children, otherwise false.
 */
fun Component.containsPlaceholder(): Boolean {
    fun recurse(comp: Component): Boolean {
        if (comp is TextComponent) {
            if (PLACEHOLDER_REGEX.containsMatchIn(comp.content())) {
                return true
            }
        }
        for (child in comp.children()) {
            if (recurse(child)) return true
        }
        return false
    }
    return recurse(this)
}

fun String.hasPlaceholder(): Boolean {
    return PLACEHOLDER_REGEX.containsMatchIn(this)
}

/**
 * Converts a string containing MiniMessage-formatted text or color codes into a `Component` object.
 * The method performs the following:
 * - Replaces legacy color codes (e.g., `&a`) with MiniMessage tags (e.g., `<green>`).
 * - Deserializes the transformed string into a `Component` using MiniMessage.
 * - Provides support for custom tags such as `ccmd` and `locale`, resolved using their respective resolvers.
 *
 * Custom tags:
 * - `ccmd`: Resolves into a tag that executes a console command when clicked.
 * - `locale`: Resolves into a tag that handles translations based on locale identifiers.
 *
 * @return Transformed `Component` with MiniMessage formatting and custom tag support applied.
 */
fun String.toMMComponent(): Component {
    return MiniMessage.builder().build().deserialize(
            this
                .replace("ยง", "&")
                .replace("&a", "<green>")
                .replace("&c", "<red>")
                .replace("&b", "<aqua>")
                .replace("&e", "<yellow>")
                .replace("&6", "<gold>")
                .replace("&d", "<light_purple>")
                .replace("&f", "<white>")
                .replace("&3", "<dark_aqua>")
                .replace("&9", "<blue>")
                .replace("&7", "<gray>")
                .replace("&8", "<dark_gray>")
                .replace("&4", "<dark_red>")
                .replace("&1", "<dark_blue>")
                .replace("&4", "<dark_red>")
                .replace("&8", "<dark_gray>")
                .replace("&2", "<dark_green>")
                .replace("&5", "<dark_purple>")
                .replace("&0", "<black>")
                .replace("&k", "<obfuscated>")
                .replace("&l", "<bold>")
                .replace("&m", "<strikethrough>")
                .replace("&n", "<underlined>")
                .replace("&o", "<italic>")
                .replace("&r", "<reset>")
        )
}
private val plainSerializer = PlainTextComponentSerializer.plainText()

fun Component.toPlain(): String {
    return plainSerializer.serialize(this)
}

fun Component.toMMString(): String {
    return MiniMessage.miniMessage().serialize(this)
}